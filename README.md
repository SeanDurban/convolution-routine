# convolution-routine
The purpose of this exercise was to better understand vectorisation, code optimisation and
parallelisation by parallelising and optimising an efficient convolution routine. We were given
a basic algorithm to start with and we optimised this basic algorithm taking into account
locality of data accesses and the multiple available processor cores of the target machine.

## Testing
Our target machine was stoker.scss.tcd.ie. This machine has four processors. Each processor
has eight out-of-order pipelined, superscalar cores and each core has two-way simultaneous
multithreading 64 threads of utilisation.


The width & height of image, kernel order, number of kernels and channels are given as
command line arguments. The image is stored as a 3D array of floats. Which is organised by
width, height and channel number. The kernel is stored as a 4D array of floats organised by
kernel number, channel number ,kernel order and kernel order. Both the image and the
kernel are randomly generated by the program with the given parameters.
We will use ​‘x86intrin.h’for SSE instructions. This header file is part of gcc, which is used to
compile the program with the highest level (03) of compiler optimisations we used the
following command:
```
gcc -03 -msse4 -fopenmp conv-harness.c
```
To test the program we ran the compiled program and used time in milliseconds, the time it takes to run our optimised routine and the basic
routine. The difference in times is calculated are printed to the console in terms of the speed
markup. The two resulting outputs are also compared and the absolute sum of difference
between the correct basic algorithm and our optimised one is calculated and printed too.

## Results
For example of results and more in-dept analysis of the optimisation methods implemented please refer the report.
